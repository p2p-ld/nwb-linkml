from __future__ import annotations
from datetime import datetime, date
from enum import Enum
from typing import List, Dict, Optional, Any, Union
from pydantic import BaseModel as BaseModel, Field
from nptyping import NDArray, Shape, Float, Float32, Double, Float64, LongLong, Int64, Int, Int32, Int16, Short, Int8, UInt, UInt32, UInt16, UInt8, UInt64, Number, String, Unicode, Unicode, Unicode, String, Bool, Datetime64
import sys
if sys.version_info >= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal


from .hdmf_common_table import (
    DynamicTableRegion
)

from .nwb_language import (
    Arraylike
)


metamodel_version = "None"
version = "None"

class WeakRefShimBaseModel(BaseModel):
   __slots__ = '__weakref__'

class ConfiguredBaseModel(WeakRefShimBaseModel,
                validate_assignment = True,
                validate_all = True,
                underscore_attrs_are_private = True,
                extra = 'forbid',
                arbitrary_types_allowed = True,
                use_enum_values = True):
    pass


class ElectricalSeriesData(ConfiguredBaseModel):
    """
    Recorded voltage data.
    """
    unit: Optional[str] = Field(None, description="""Base unit of measurement for working with the data. This value is fixed to 'volts'. Actual stored values are not necessarily stored in these units. To access the data in these units, multiply 'data' by 'conversion', followed by 'channel_conversion' (if present), and then add 'offset'.""")
    array: Optional[NDArray[Shape["* num_times, * num_channels, * num_samples"], Number]] = Field(None)
    

class ElectricalSeriesDataArray(Arraylike):
    
    num_times: float = Field(...)
    num_channels: Optional[float] = Field(None)
    num_samples: Optional[float] = Field(None)
    

class ElectricalSeriesElectrodes(DynamicTableRegion):
    """
    DynamicTableRegion pointer to the electrodes that this time series was generated from.
    """
    table: Optional[DynamicTable] = Field(None, description="""Reference to the DynamicTable object that this region applies to.""")
    description: Optional[str] = Field(None, description="""Description of what this table region points to.""")
    array: Optional[NDArray[Shape["* dim0, * dim1, * dim2, * dim3"], ]] = Field(None)
    

class ElectricalSeriesChannelConversion(ConfiguredBaseModel):
    """
    Channel-specific conversion factor. Multiply the data in the 'data' dataset by these values along the channel axis (as indicated by axis attribute) AND by the global conversion factor in the 'conversion' attribute of 'data' to get the data values in Volts, i.e, data in Volts = data * data.conversion * channel_conversion. This approach allows for both global and per-channel data conversion factors needed to support the storage of electrical recordings as native values generated by data acquisition systems. If this dataset is not present, then there is no channel-specific conversion factor, i.e. it is 1 for all channels.
    """
    axis: Optional[int] = Field(None, description="""The zero-indexed axis of the 'data' dataset that the channel-specific conversion factor corresponds to. This value is fixed to 1.""")
    channel_conversion: Optional[List[float]] = Field(default_factory=list, description="""Channel-specific conversion factor. Multiply the data in the 'data' dataset by these values along the channel axis (as indicated by axis attribute) AND by the global conversion factor in the 'conversion' attribute of 'data' to get the data values in Volts, i.e, data in Volts = data * data.conversion * channel_conversion. This approach allows for both global and per-channel data conversion factors needed to support the storage of electrical recordings as native values generated by data acquisition systems. If this dataset is not present, then there is no channel-specific conversion factor, i.e. it is 1 for all channels.""")
    

class SpikeEventSeriesData(ConfiguredBaseModel):
    """
    Spike waveforms.
    """
    unit: Optional[str] = Field(None, description="""Unit of measurement for waveforms, which is fixed to 'volts'.""")
    array: Optional[NDArray[Shape["* num_events, * num_samples, * num_channels"], Number]] = Field(None)
    

class SpikeEventSeriesDataArray(Arraylike):
    
    num_events: float = Field(...)
    num_samples: float = Field(...)
    num_channels: Optional[float] = Field(None)
    

class SpikeEventSeriesTimestamps(ConfiguredBaseModel):
    """
    Timestamps for samples stored in data, in seconds, relative to the common experiment master-clock stored in NWBFile.timestamps_reference_time. Timestamps are required for the events. Unlike for TimeSeries, timestamps are required for SpikeEventSeries and are thus re-specified here.
    """
    interval: Optional[int] = Field(None, description="""Value is '1'""")
    unit: Optional[str] = Field(None, description="""Unit of measurement for timestamps, which is fixed to 'seconds'.""")
    timestamps: List[float] = Field(default_factory=list, description="""Timestamps for samples stored in data, in seconds, relative to the common experiment master-clock stored in NWBFile.timestamps_reference_time. Timestamps are required for the events. Unlike for TimeSeries, timestamps are required for SpikeEventSeries and are thus re-specified here.""")
    

class FeatureExtractionDescription(ConfiguredBaseModel):
    """
    Description of features (eg, ''PC1'') for each of the extracted features.
    """
    description: List[str] = Field(default_factory=list, description="""Description of features (eg, ''PC1'') for each of the extracted features.""")
    

class FeatureExtractionFeatures(ConfiguredBaseModel):
    """
    Multi-dimensional array of features extracted from each event.
    """
    array: Optional[NDArray[Shape["* num_events, * num_channels, * num_features"], Float32]] = Field(None)
    

class FeatureExtractionFeaturesArray(Arraylike):
    
    num_events: Optional[float] = Field(None)
    num_channels: Optional[float] = Field(None)
    num_features: Optional[float] = Field(None)
    

class FeatureExtractionTimes(ConfiguredBaseModel):
    """
    Times of events that features correspond to (can be a link).
    """
    times: List[float] = Field(default_factory=list, description="""Times of events that features correspond to (can be a link).""")
    

class FeatureExtractionElectrodes(DynamicTableRegion):
    """
    DynamicTableRegion pointer to the electrodes that this time series was generated from.
    """
    table: Optional[DynamicTable] = Field(None, description="""Reference to the DynamicTable object that this region applies to.""")
    description: Optional[str] = Field(None, description="""Description of what this table region points to.""")
    array: Optional[NDArray[Shape["* dim0, * dim1, * dim2, * dim3"], ]] = Field(None)
    

class EventDetectionSourceIdx(ConfiguredBaseModel):
    """
    Indices (zero-based) into source ElectricalSeries::data array corresponding to time of event. ''description'' should define what is meant by time of event (e.g., .25 ms before action potential peak, zero-crossing time, etc). The index points to each event from the raw data.
    """
    source_idx: List[int] = Field(default_factory=list, description="""Indices (zero-based) into source ElectricalSeries::data array corresponding to time of event. ''description'' should define what is meant by time of event (e.g., .25 ms before action potential peak, zero-crossing time, etc). The index points to each event from the raw data.""")
    

class EventDetectionTimes(ConfiguredBaseModel):
    """
    Timestamps of events, in seconds.
    """
    unit: Optional[str] = Field(None, description="""Unit of measurement for event times, which is fixed to 'seconds'.""")
    times: List[float] = Field(default_factory=list, description="""Timestamps of events, in seconds.""")
    

class ClusterWaveformsWaveformMean(ConfiguredBaseModel):
    """
    The mean waveform for each cluster, using the same indices for each wave as cluster numbers in the associated Clustering module (i.e, cluster 3 is in array slot [3]). Waveforms corresponding to gaps in cluster sequence should be empty (e.g., zero- filled)
    """
    array: Optional[NDArray[Shape["* num_clusters, * num_samples"], Float32]] = Field(None)
    

class ClusterWaveformsWaveformMeanArray(Arraylike):
    
    num_clusters: Optional[float] = Field(None)
    num_samples: Optional[float] = Field(None)
    

class ClusterWaveformsWaveformSd(ConfiguredBaseModel):
    """
    Stdev of waveforms for each cluster, using the same indices as in mean
    """
    array: Optional[NDArray[Shape["* num_clusters, * num_samples"], Float32]] = Field(None)
    

class ClusterWaveformsWaveformSdArray(Arraylike):
    
    num_clusters: Optional[float] = Field(None)
    num_samples: Optional[float] = Field(None)
    

class ClusteringNum(ConfiguredBaseModel):
    """
    Cluster number of each event
    """
    num: List[int] = Field(default_factory=list, description="""Cluster number of each event""")
    

class ClusteringPeakOverRms(ConfiguredBaseModel):
    """
    Maximum ratio of waveform peak to RMS on any channel in the cluster (provides a basic clustering metric).
    """
    peak_over_rms: List[float] = Field(default_factory=list, description="""Maximum ratio of waveform peak to RMS on any channel in the cluster (provides a basic clustering metric).""")
    

class ClusteringTimes(ConfiguredBaseModel):
    """
    Times of clustered events, in seconds. This may be a link to times field in associated FeatureExtraction module.
    """
    times: List[float] = Field(default_factory=list, description="""Times of clustered events, in seconds. This may be a link to times field in associated FeatureExtraction module.""")
    


# Update forward refs
# see https://pydantic-docs.helpmanual.io/usage/postponed_annotations/
ElectricalSeriesData.update_forward_refs()
ElectricalSeriesDataArray.update_forward_refs()
ElectricalSeriesElectrodes.update_forward_refs()
ElectricalSeriesChannelConversion.update_forward_refs()
SpikeEventSeriesData.update_forward_refs()
SpikeEventSeriesDataArray.update_forward_refs()
SpikeEventSeriesTimestamps.update_forward_refs()
FeatureExtractionDescription.update_forward_refs()
FeatureExtractionFeatures.update_forward_refs()
FeatureExtractionFeaturesArray.update_forward_refs()
FeatureExtractionTimes.update_forward_refs()
FeatureExtractionElectrodes.update_forward_refs()
EventDetectionSourceIdx.update_forward_refs()
EventDetectionTimes.update_forward_refs()
ClusterWaveformsWaveformMean.update_forward_refs()
ClusterWaveformsWaveformMeanArray.update_forward_refs()
ClusterWaveformsWaveformSd.update_forward_refs()
ClusterWaveformsWaveformSdArray.update_forward_refs()
ClusteringNum.update_forward_refs()
ClusteringPeakOverRms.update_forward_refs()
ClusteringTimes.update_forward_refs()
